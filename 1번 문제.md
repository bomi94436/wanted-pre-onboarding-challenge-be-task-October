- 적용가능한 방법은 다음 두가지가 있습니다
    - 방법1) A 사용자가 데이터를 조회하고 업데이트하는 동안, B 사용자는 수정하지 못하도록 막는다 = `선점 잠금`
        - 한 사용자가 접근중일 경우, 다른 사용자는 블로킹됨
        - DBMS의 잠금기능을 통해 구현가능
        - 여러개의 트랜잭션이 커밋을 하지않은 채 여러개를 선점하려는 경우 교착상태에 빠질 확률이 높음
            - 예를들면
                - 트랜잭션 1이 A테이블의 첫번째 항목의 잠금을 구함
                - 트랜잭션 2가 B테이블의 첫번째 항목의 잠금을 구함
                - 트랜잭션 1이 커밋을 하지않은 채 추가로 B테이블의 첫번째 항목의 잠금을 구하는것을 시도
                - 트랜잭션 2가 커밋을 하지않은 채 추가로 A테이블의 첫번째 항목의 잠금을 구하는것을 시도
                - ⇒ 트랜잭션 1과 2는 아무것도 할 수 없는 교착상태에 빠지게 된다
                - 영원한 교착상태에 빠지지 않도록 하기위해 잠금을 구하기위한 최대 대기시간을 지정할 수 있음
    - 방법2) A 사용자가 조회한 이후에 B 사용자에 의한 업데이트가 일어나면, A 사용자는 다시 조회 후 업데이트 하도록 한다 = `비선점 잠금`
        - 선점 잠금의 경우 동시에 업데이트를 요청하는 항목에 대해서는 처리할 수 있을 지 몰라도, 조회와 업데이트가 서로 다른 시간에 이루어지는 경우에는 해결할 수 없음
            - 예를들면
                - A 사용자가 제품 배송을 위한 주문정보를 조회함
                - B 사용자가 배송지 변경을 위한 변경 폼을 조회함
                - B 사용자가 새로운 배송지로 업데이트함
                - A 사용자가 조회했던 주문정보의 배송지를 토대로 배송 상태를 변경함
                - ⇒ 이 경우 B 사용자는 배송지를 변경했지만, A 사용자에 의해 덮어씌워지게 됨
        - 비선점 잠금은 변경할 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방법임
            - 테이블에 항목이 업데이트 될 때 마다 값이 증가하는 버전용 컬럼을 추가
            - 업데이트를 요청할 때의 버전용 컬럼값과 조회를 했을 때의 버전용 컬럼 값이 다르면 트랜잭션 커밋을 실패하도록 처리 → 사용자가 다시 조회 후 업데이트를 수행할 수 있도록
